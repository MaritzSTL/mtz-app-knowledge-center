Polymer and web components make a promise that other javascript web frameworks aren't structurally suited to deliver on: the competitive web. And that's because the only way you can make the web better, and faster, is to send less stuff. Devices spend most of their time being not useful with network requests, and parsing javascript. If the browser does more, you can send less.

## Why Programs Exist

Strictly speaking, you don't ever write code to write code. I don't mean "*you can't spend nights and weekends coding for pleasure, you must always code for work!*" But code is just like speech. You don't speak just to speak, you speak so you're heard. So someone else receives, understands, is moved. Without that person at the other end, why speak at all in the first place? The act of speaking loses it's value, especially if much more efficient forms of communication with yourself exist. If you don't have other people you need to influence, rhetoric isn't worth anything.

Software is like speaking, in that the only reason it exists is because it helps other people get some sort of job done. Without that job getting accomplished at the other end, all the supporting infrastructure behind code wouldn't be worth it.

In exchange for taking some scarcity in the world, and building a system that makes that previously scarce/valuable resource abundant, people pay money for it. (For example, that kern machine that sends out the oodles of letters takes the previously scarce resource of preparing letters, and makes it abundant.) Code is often taking the expertise of a person and putting that expertise into a computer. Code is just thought. It's a series of selections from how the world really is explained so clearly a computer can understand and behave with either the judgement or skill of a human in a specific area. So the best code, and the best programmer is not so much directly a programmer, but a system that's capable of efficiently and valuably interpreting and communicating the process of the real world in software.

What's scarce in any organization deploying software is usually money. And since all other sorts of costs can be translated into money (which is one of the main purposes of money, after all), it's a really efficient way of talking about software. So the right way of talking about software is in dosages of cost: both how much, and when.

I think, pound for pound, Polymer/Web Components have a somewhat uncapped upside in the amount of value you can get per unit of cost. In plain english, I think I'll be able to ship FAR more awesome software far faster and cheaper than any of the other alternatives.

That said, given my time using it, I think there's a specific of tools and approaches that either need to be adopted or built in order to realize this completely asymmetrical gain. AKA, if you wanna be able to ship maintainable code that gets the job done really fast, there's some stuff missing.

## Simple vs Easy

Before I dive in, I need to make a distinction.

A thing is **simple** when it adopts the minimum amount of complexity needed to achieve it's purpose. This doesn't mean, it lacks complexity. If you're dealing with a really complicated domain, you will necessarily need some amount of complexity. Simple means a thing lacks *unnecessary* complexity.

**Easy** means familiar. Something's easy if you're familiar with it. People don't like stuff they suck at, and how good you are at something is usually a function of how much time you've spent trying to get good at it.

Ease tends to correspond with simplicity. The simpler something is, the quicker you can pick it up. But it also introduces a dynamic where people won't want to adopt an approach that is actually simpler (and better adapted to the problem it's meant to solve) because it's not "easy." Which almost always means means they're not familiar with it.

## "Stuck"-ness

The worst part of Polymer is when you want to do something, and you get stuck. You're not sure where to go next, what to think, even what to guess.

This "stuck-ness" happens because the documentation is written by highly technical people, for highly technical people. This is because Polymer team's market entry strategy is centered around getting adoption and usage at specific large companies. It's really hard to build an accurate, useful mental model that will let you guess what to try next.


Why programs exist
Simple vs Easy
"Stuck"-ness
Tooling
Framework:
  Scope
  State Management
Quantitative Analysis
Exporting/Importing Bugs
