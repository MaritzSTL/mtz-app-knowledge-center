The browser you're using to read this is, in my opinion, kind of a marvelous achievement of mankind. Under the hood, it's running on an engine. To understand this whole Polymer/Web Components thing, all you have to do is understand one really simple dynamic about how this engine operates.

So, I know the title says `<div>`, but I'm gonna actually gonna be talking about a different tag that's way easier to show.

## The <p> tag

The internet is a series of text files computers fling at each other. Here's what one of those looks like:

![example.html in the folder](images/chapters/1/00.png)

It's a file, just like any other. Here's what's inside of it:

![example.html contents](images/chapters/1/01.png)

When you double-click it, your computer will open it in a browser. Here's what you get:

![example.html rendered](images/chapters/1/02.png)

That `<p>This is a paragraph</p>` is called a paragraph tag. Whatever you put inside of it will show up as text, exactly like you might expect.

So, that's it. That's the agreement. It's that simple. If you, in your text file, add a `<p>` tag, any browser anywhere will render whatever you put inside of it as text.

The browser comes with a default toolset, a bundle of supported tags you can use. Every web page you read, every tweet you moan about, they're all built out of these tags. This is how the internet is built.

But what happens if we do this?

![example.html with internet shark first added](images/chapters/1/03.png)

We added `<internet-shark></internet-shark>`. So now what will happen when we open it in our browser?

![example.html rendered](images/chapters/1/02.png)

Nothing. Absolutely nothing. You see, since `<internet-shark>` isn't in the default toolkit of tags we get to use, our browser doesn't know what to do with it. And historically, this is how the internet has always been.

Until now.

## Adding the internet shark

The most important thing this whole web components effort provides is the ability to let us add new tags. Or, in more accurate parlance, *elements*. They let us make new agreements with the browser, "when you see this thing, do that thing."

So, how do we make our new internet shark tag work? We have to register a new, custom, element and tell it what to do and how to behave. We're skipping the gory, technical details of how to do that for now, but will cover that in-depth later. (Specifically in [Custom Elements](/chapter/3)) But there's one line of code that's important:

```
document.registerElement('internet-shark', {prototype: InternetShark});
```

This is where we're creating a new agreement with our browser on, "if you see `<internet-shark>`, here's what you do."

So, if we go ahead and build out this new `<internet-shark>` element and tell the browser about it... what happens?

![internet shark first render](images/chapters/1/04.png)

**Boom!** Now our browser knows what to do when it sees that text. This is what fundamentally new kind of building material to work with.

So what? Why is this one, simple thing such a big deal?

Well it's hard to know how this checks so many boxes when you don't even know what the boxes are.

## Why choose one programming language or another?

There are building materials, and there are building tools. Each has a set of properties which make it better or worse in certain situations. Have you ever tried hammering a nail in with a screwdriver? That would require a ton of unnecessary effort. Or hammering in a screw? That defeats the purpose of the screw - using a screw in such a way goes against its nature. (Why hammer in a screw when you have a perfectly good nail nearby?)

Programming languages and tools are much the same way. They have properties that make them better or worse suited for certain tasks. Depending on which tools you select and how you put them together, you're adopting a different configuration of costs.

So, for any business, costs are a given. What's actually important, and where all technical discussion needs to be centered around, is both the timing and the dosage of the various costs. If you have too high of a dose of cost at the wrong time, that can sink your business. Alternatively, if you can significantly lower your total cost by adopting a higher initial dose, that's a great trade. But as a counterexample, as a startup, if you're going to hit the end of your runway next month, it's worth making decisions now that will result in revenue but lead to extremely high costs later because the alternative is not existing.

Point is, different businesses will have different costs, and different configurations of what technical tools are selected that make sense for them. And as you make different selections, you sometimes make the cost of changing a decision so expensive it's practically eliminated.

Cost is where the scarcity in software is. Good technical decisions are business-specific decisions around cost. And this is what makes something as simple as being able to define your own custom elements so exciting. It gets exciting when you investigate what inherent properties and nature it has, compared to it's alternatives.

Any data-intensive technical system's costs are distributed across three areas:

1. Reliability
2. Scalability
3. Maintainability

And, of the three, maintainability is far far away the largest portion of cost.

> It is well known that the majority of the cost of software is not in it's initial development, but in it's ongoing maintenance. - Martin Kleppman

So when your browser receives an HTML document and turns it into a usable web page, it's right there, that's where we need to investigate costs. This specific segment of the technical stack is called the "front-end" (back-end being the servers which send the html document). What are the boxes that need to be checked? What are the inherent properties and tradeoffs of the tools that we can choose from? For these custom elements, for this whole Polymer/Web Components thing, what are the costs of maintenance like? And when you choose one tool or another, what other choices are made unavailable?

## Zooming in: Polymer/Web Components

Here's what a front-end approach of *any* kind need to be able to deliver:

- Responsiveness (showing up nicely on all different devices)
- Internationalization (also called i18n)
- Customizability (ex: setting colors, logo, etc on a per-client basis)
- Optionality to have offline expansion
- Performance (<100ms to interactive on desktop, <5s to interactive on mobile)
- Ability to just drop in and reuse both what you, and other people have built

So every front-end approach can handle all these areas in different ways. But in this list, where is the scarcity? Where are the most substantive tradeoffs?

There is a hard limit in one area: performance. On most of the devices most of the people across the world are currently and will be consuming the internet on, rendering a traditional javascript-framework based frontend takes 15-20 seconds. The majority of that time is spent making network requests, and the device trying to process all the javascript. This means there's fundamentally only one way to improve performance: send less stuff.

There are no optimizations that can possibly be made at the javascript layer to improve performance, unless those optimizations involve sending less stuff.

If the browser can do more, then you can send a lot less stuff. But this goes even further. What if you sliced up your website into a bunch of little pieces, sent over only exactly what was needed, loaded those pieces in the most efficient ways, and cumulatively built up the entire website on someone's computer?

![javascript vs browser based optimizations](images/chapters/1/05.png)

Well, that's actually what this site you're reading does! :)

That's why being able to make your own custom elements and this whole Polymer/web components approach is such a big deal. That's why something so simple as being able to enhance the browser, to add `<internet-shark>`, is actually huge.

It's about reaching everyone.
